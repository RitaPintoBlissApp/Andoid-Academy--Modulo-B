fun main() {
    
   /* val numbers = listOf(0, 3, 8, 4, 0, 5, 5, 8, 9, 2)
    println("list: ${numbers}")
    println("sorted: ${numbers.sorted()}")
    
    val setOfNumbers = numbers.toSet()
    println("set: ${setOfNumbers}")
    
    val set1 = setOf(1,2,3)
    val set2 = mutableSetOf(3,2,1)
    println("$set1 == $set2 : ${set1 == set2}")
    println("contains 7: ${setOfNumbers.contains(7)}")*/
    /*
    
    val peopleAges = mutableMapOf<String, Int>(
    "Fred" to 30,
    "Ann" to 23
    )
    peopleAges.put("Barbara", 42)
    peopleAges["Joe"]=51
    peopleAges["Fred"] = 31
    println(peopleAges)
    //função forEach
    peopleAges.forEach{print("${it.key} is ${it.value}, ")}
    //função map
    println(peopleAges.map { "${it.key} is ${it.value}" }.joinToString(", ") )
    
    /*
     * A função peopleAges.map aplica uma transformação em cada item em peopleAges e cria uma nova coleção dos itens transformados
       A parte {} entre chaves define a transformação a ser aplicada em cada item. A transformação usa um par de chave-valor em uma string, por exemplo, <Fred, 31> se transforma em Fred is 31.
       A função joinToString(", ") adiciona cada item na coleção transformada a uma string, separada por uma , e sabe que não precisa adicioná-la ao último item.
       Tudo isso é unido com um . (operador de ponto), como você fez com as chamadas de função e acessos de propriedade em codelabs anteriores.*/
       val filteredNames = peopleAges.filter { it.key.length < 4 }
       println(filteredNames)
    
    val triple: (Int) -> Int = { a: Int -> a * 3}
    println(triple(5))
    val peopleNames = listOf("Fred", "Ann", "Barbara", "Joe")
    println(peopleNames.sorted())
    println(peopleNames.sortedWith { str1: String, str2: String -> str1.length - str2.length })
 
    calculateButton.setOnClickListener { calculateTip() }*/

    
    //################## EXERCICIO FINAL ################## 
    
    //lista de palavras
     val words = listOf("about", "acute", "awesome", "balloon", "best", "brief", "class", "coffee", "creative")
     
     //quero aceder a palavras q começem com a letra B
     val filteredWords = words.filter { it.startsWith("b", ignoreCase = true) }
     //println(filteredWords)
     //startsWith-> retornará como verdadeira se uma string começar com a string especificada.
     //.shuffled()
     .shuffled()
    .take(2)
     .sorted()
    println(filteredWords)

     
     
     
     
     
     
}
